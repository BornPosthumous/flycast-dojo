#include "DojoGui.hpp"
#include <oslib/audiostream.h>
namespace fs = ghc::filesystem;

void DojoGui::gui_display_bios_rom_warning(float scaling)
{
	std::string current_bios;
	if (settings.platform.system == DC_PLATFORM_NAOMI)
		current_bios = "naomi.zip";
	else if (settings.platform.system == DC_PLATFORM_ATOMISWAVE)
		current_bios = "awbios.zip";

	std::string file_path = settings.imgread.ImagePath;
	std::string current_filename = file_path.substr(file_path.find_last_of("/\\") + 1);

	std::string designation, start_msg, file_d;

	if (!bios_json_match && !current_json_match)
	{
		designation = "BIOS & ROM";
		start_msg = current_bios + " & " + current_filename + " do";
		file_d = "files";
	}
	else if (!bios_json_match)
	{
		designation = "BIOS";
		start_msg = current_bios + " does";
		file_d = "file";
	}
	else if (!current_json_match)
	{
		designation = "ROM";
		start_msg = current_filename + " does";
		file_d = "file";
	}

	std::string popup_title = designation + " Mismatch";


	ImGui::OpenPopup(popup_title.data());
	if (ImGui::BeginPopupModal(popup_title.data(), NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiInputTextFlags_EnterReturnsTrue))
	{
		std::string msg = start_msg + " not match the checksum of community-recommended " + file_d + ".\nPlease find a new " + designation + " and try again.";
		ImGui::TextColored(ImVec4(128, 0, 0, 1), "WARNING");
		ImGui::TextColored(ImVec4(128, 128, 0, 1), msg.data());
		std::string msg_2 = "Having a different " + designation + " than your opponent may result in desyncs.\nProceed at your own risk.";
		ImGui::Text(msg_2.data());

		if (ImGui::Button("Continue"))
		{
			if (config::DojoActAsServer)
			{
				dojo.host_status = 1;
				if (config::EnableLobby)
					dojo.remaining_spectators = config::Transmitting ? 1 : 0;
				else
					dojo.remaining_spectators = 0;
				gui_open_host_wait();
			}
			else
				gui_open_guest_wait();
		}

		/*
		ImGui::SameLine();
		if (ImGui::Button("Cancel"))
		{
			ImGui::CloseCurrentPopup();

			// Exit to main menu
			gui_state = GuiState::Main;
			game_started = false;
			settings.imgread.ImagePath[0] = '\0';
			dc_reset(true);
		}
		*/

		ImGui::EndPopup();
	}

}

void DojoGui::gui_open_host_delay()
{
	gui_state = GuiState::HostDelay;
}

void DojoGui::gui_display_host_wait(float scaling)
{
	//dc_stop();

	ImGui::SetNextWindowPos(ImVec2(screen_width / 2.f, screen_height / 2.f), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
	ImGui::SetNextWindowSize(ImVec2(330 * scaling, 0));

	ImGui::Begin("##host_wait", NULL, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysAutoResize);

	ImGui::Text("Waiting for opponent to connect...");

	if (config::EnableMatchCode && !config::MatchCode.get().empty())
	{
		ImGui::Text("Match Code: %s", config::MatchCode.get().data());
		if (ImGui::Button("Copy Match Code"))
		{
			SDL_SetClipboardText(config::MatchCode.get().data());
		}
	}

	/*
	ImGui::SameLine();
	if (ImGui::Button("Cancel"))
	{
		ImGui::CloseCurrentPopup();

		// Exit to main menu
		gui_state = GuiState::Main;
		game_started = false;
		settings.imgread.ImagePath[0] = '\0';
		dc_reset(true);
	}
	*/

	if (!dojo.OpponentIP.empty())
	{
		dojo.host_status = 2;
		dojo.OpponentPing = dojo.DetectDelay(dojo.OpponentIP.data());

		gui_state = GuiState::Closed;
		gui_open_host_delay();
	}

	if (config::Transmitting &&
		dojo.remaining_spectators == 0)
	{
		if (config::EnableLobby)
			ImGui::Text("This match will be spectated.");
	}

	ImGui::End();
}

void DojoGui::gui_display_guest_wait(float scaling)
{
	//dc_stop();

	dojo.pause();

	ImGui::SetNextWindowPos(ImVec2(screen_width / 2.f, screen_height / 2.f), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
	ImGui::SetNextWindowSize(ImVec2(330 * scaling, 0));

	ImGui::Begin("##guest_wait", NULL, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysAutoResize);

	if (!dojo.client.name_acknowledged)
	{
		if (config::EnableMatchCode && config::MatchCode.get().empty())
		{
			ImGui::OpenPopup("Match Code");
			if (ImGui::BeginPopupModal("Match Code", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiInputTextFlags_EnterReturnsTrue))
			{
				ImGui::Text("Enter Match Code generated by host.");

				static char mc[128] = "";
				ImGui::InputTextWithHint("", "ABC123", mc, IM_ARRAYSIZE(mc), ImGuiInputTextFlags_CharsUppercase);

				ImGui::SameLine();
				if (ImGui::Button("Paste"))
				{
					char* pasted_txt = SDL_GetClipboardText();
					memcpy(mc, pasted_txt, strlen(pasted_txt));
				}

				if (ImGui::Button("Start Session"))
				{
					dojo.MatchCode = std::string(mc, strlen(mc));
					ImGui::CloseCurrentPopup();
				}

				/*
				ImGui::SameLine();
				if (ImGui::Button("Cancel"))
				{
					ImGui::CloseCurrentPopup();

					// Exit to main menu
					gui_state = GuiState::Main;
					game_started = false;
					settings.imgread.ImagePath[0] = '\0';
					dc_reset(true);
				}
				*/

				ImGui::EndPopup();
			}
		}
		else if (config::DojoServerIP.get().empty())
		{
   			ImGui::OpenPopup("Connect to Host Server");
   			if (ImGui::BeginPopupModal("Connect to Host Server", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiInputTextFlags_EnterReturnsTrue))
   			{
   				ImGui::Text("Enter Host Server Details");

   				static char si[128] = "";
   				ImGui::InputTextWithHint("IP", "0.0.0.0", si, IM_ARRAYSIZE(si));

   				static char sp[128] = "6000";
   				ImGui::InputTextWithHint("Port", "6000", sp, IM_ARRAYSIZE(sp));

   				if (ImGui::Button("Start Session"))
   				{
					config::DojoServerIP = std::string(si, strlen(si));
					config::DojoServerPort = std::string(sp, strlen(sp));
					cfgSaveStr("dojo", "ServerIP", config::DojoServerIP.get().c_str());
					cfgSaveStr("dojo", "ServerPort", config::DojoServerPort.get().c_str());

					dojo.client.SetHost(config::DojoServerIP, atoi(config::DojoServerPort.get().data()));

   					ImGui::CloseCurrentPopup();
   				}
				
				ImGui::SameLine();
				if (ImGui::Button("Cancel"))
				{
					ImGui::CloseCurrentPopup();

					// Exit to main menu
					gui_state = GuiState::Main;
					game_started = false;
					settings.imgread.ImagePath[0] = '\0';
					dc_reset(true);

					config::DojoServerIP = "";
					cfgSaveStr("dojo", "ServerIP", config::DojoServerIP.get().c_str());
				}

   				ImGui::EndPopup();
   			}
		}

		if (!config::DojoServerIP.get().empty())
		{
			ImGui::Text("Connecting to host...");

			/*
			ImGui::SameLine();
			if (ImGui::Button("Cancel"))
			{
				ImGui::CloseCurrentPopup();

				// Exit to main menu
				gui_state = GuiState::Main;
				game_started = false;
				settings.imgread.ImagePath[0] = '\0';
				dc_reset(true);

				config::DojoServerIP = "";
				cfgSaveStr("dojo", "ServerIP", config::DojoServerIP.data().c_str());
			}
			*/

			dojo.client.SendPlayerName();
		}
	}
	else
	{
		ImGui::Text("Waiting for host to select delay...");
	}

	if (dojo.session_started)
	{
		gui_state = GuiState::Closed;
		dojo.resume();
	}

	ImGui::End();
}

void DojoGui::gui_display_disconnected( float scaling)
{
	ImGui::SetNextWindowPos(ImVec2(screen_width / 2.f, screen_height / 2.f), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
	ImGui::SetNextWindowSize(ImVec2(330 * scaling, 0));

	ImGui::Begin("##disconnected", NULL, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysAutoResize);

	if (dojo.client.opponent_disconnected)
		ImGui::Text("Opponent disconnected.");
	else
		ImGui::Text("Disconnected.");

	ImGui::End();

	config::AutoSkipFrame = 1;
}

void DojoGui::gui_display_end_replay( float scaling)
{
	ImGui::SetNextWindowPos(ImVec2(screen_width / 2.f, screen_height / 2.f), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
	ImGui::SetNextWindowSize(ImVec2(330 * scaling, 0));

	ImGui::Begin("##end_replay", NULL, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysAutoResize);

	ImGui::Text("End of replay.");

	ImGui::End();
}

void DojoGui::gui_display_end_spectate( float scaling)

{
	dc_stop();

	ImGui::SetNextWindowPos(ImVec2(screen_width / 2.f, screen_height / 2.f), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
	ImGui::SetNextWindowSize(ImVec2(330 * scaling, 0));

	ImGui::Begin("##end_spectate", NULL, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysAutoResize);

	ImGui::Text("End of spectated match.");

	ImGui::End();
}

void DojoGui::gui_display_host_delay( float scaling)

{
	//dc_stop();

	dojo.pause();

	ImGui::SetNextWindowPos(ImVec2(screen_width / 2.f, screen_height / 2.f), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
	ImGui::SetNextWindowSize(ImVec2(360 * scaling, 0));

	ImGui::Begin("##host_delay", NULL, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysAutoResize);

	// if both player names are defaults, hide names
	if (!(config::PlayerName.get().compare("Player") == 0 &&
		config::PlayerName.get().compare(config::OpponentName.get()) == 0))
	{
		ImGui::Text("%s vs %s", config::PlayerName.get().c_str(), config::OpponentName.get().c_str());
	}

	ImGui::SliderInt("", (int*)&config::Delay.get(), 1, 10);
	ImGui::SameLine();
	ImGui::Text("Set Delay");

	if (ImGui::Button("Detect Delay"))
		dojo.OpponentPing = dojo.DetectDelay(dojo.OpponentIP.data());

	if (dojo.OpponentPing > 0)
	{
		ImGui::SameLine();
		ImGui::Text("Current Ping: %d ms", dojo.OpponentPing);
	}

	if (ImGui::Button("Start Game"))
	{
		dojo.PlayMatch = false;
		if (config::Transmitting &&
			dojo.remaining_spectators == 0)
		{
			dojo.StartTransmitterThread();
		}

		dojo.isMatchStarted = true;
		dojo.StartSession(config::Delay.get(),
			config::PacketsPerFrame,
			config::NumBackFrames);
		dojo.resume();

		gui_state = GuiState::Closed;
	}

	SaveSettings();

	ImGui::End();
}

void DojoGui::gui_display_test_game( float scaling)

{
	dc_stop();

	ImGui::SetNextWindowPos(ImVec2(screen_width / 2.f, screen_height / 2.f), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
	ImGui::SetNextWindowSize(ImVec2(330 * scaling, 0));

	ImGui::Begin("##test_game", NULL, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysAutoResize);

	ImGui::Columns(2, "buttons", false);
	if (ImGui::Button("Settings", ImVec2(150 * scaling, 50 * scaling)))
	{
		gui_state = GuiState::Settings;
	}
	ImGui::NextColumn();
	if (ImGui::Button("Start Game", ImVec2(150 * scaling, 50 * scaling)))
	{
		gui_state = GuiState::Closed;
		gui_start_game(settings.imgread.ImagePath);
	}

	ImGui::End();
}

std::vector<std::string> split(const std::string& text, char delimiter) {
    std::string tmp;
    std::vector<std::string> stk;
    std::stringstream ss(text);
    while(getline(ss,tmp, delimiter)) {
        stk.push_back(tmp);
    }
    return stk;
}

void DojoGui::gui_display_lobby(float scaling, std::vector<GameMedia> game_list)
{
	if (!dojo.lobby_active)
	{
		std::thread t4(&DojoLobby::ListenerThread, std::ref(dojo.presence));
		t4.detach();
	}

	ImGui::SetNextWindowPos(ImVec2(0, 0));
	ImGui::SetNextWindowSize(ImVec2(screen_width, screen_height));
	ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0);

	ImGui::Begin("Lobby", NULL, /*ImGuiWindowFlags_AlwaysAutoResize |*/ ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoCollapse);
	ImVec2 normal_padding = ImGui::GetStyle().FramePadding;
	
	if (ImGui::Button("Done", ImVec2(100 * scaling, 30 * scaling)))
	{
		if (game_started)
    		gui_state = GuiState::Commands;
    	else
    		gui_state = GuiState::Main;
	}

	ImGui::SameLine(ImGui::GetContentRegionAvail().x - ImGui::CalcTextSize("Host Game").x - ImGui::GetStyle().FramePadding.x * 2.0f - ImGui::GetStyle().ItemSpacing.x);
	if (ImGui::Button("Host Game", ImVec2(100 * scaling, 30 * scaling)))
	{
		config::ActAsServer = true;
		cfgSaveBool("dojo", "ActAsServer", config::ActAsServer);
		gui_state = GuiState::Main;
	}

	ImGui::Columns(4, "mycolumns"); // 4-ways, with border
	ImGui::Separator();
	ImGui::SetColumnWidth(0, ImGui::CalcTextSize("Ping").x + ImGui::GetStyle().FramePadding.x * 2.0f + ImGui::GetStyle().ItemSpacing.x);
	//ImGui::Text("Ping"); ImGui::NextColumn();
	ImGui::Text("    "); ImGui::NextColumn();
	ImGui::Text("Players"); ImGui::NextColumn();
	ImGui::Text("Status"); ImGui::NextColumn();
	ImGui::Text("Game"); ImGui::NextColumn();
	ImGui::Separator();

	std::map<std::string, std::string> beacons = dojo.presence.active_beacons;
	for (auto it = beacons.cbegin(); it != beacons.cend(); ++it) {
		std::string s = it->second;
		std::string delimiter = "__";

		std::string beacon_id = it->first;
		std::vector<std::string> beacon_entry;

		if (dojo.presence.last_seen[beacon_id] + 10000 > dojo.unix_timestamp())
		{
			size_t pos = 0;
			std::string token;
			while ((pos = s.find(delimiter)) != std::string::npos) {
			    token = s.substr(0, pos);
			    std::cout << token << std::endl;
				beacon_entry.push_back(token);
			    s.erase(0, pos + delimiter.length());
			}

			std::string beacon_ip = beacon_entry[0];
			std::string beacon_server_port = beacon_entry[1];
			std::string beacon_status = beacon_entry[2];

			std::string beacon_game = beacon_entry[3].c_str();
			std::string beacon_game_path = "";

			std::string beacon_remaining_spectators = beacon_entry[5];

			std::vector<GameMedia> games = game_list;
			std::vector<GameMedia>::iterator it = std::find_if (games.begin(), games.end(),
				[&](GameMedia gm) { return ( gm.name.rfind(beacon_game, 0) == 0 ); });

			if (it != games.end())
			{
				beacon_game = it->name;
				beacon_game_path = it->path;
			}

			std::string beacon_player = beacon_entry[4];

			bool is_selected;
			int beacon_ping = dojo.presence.active_beacon_ping[beacon_id];
			std::string beacon_ping_str = "";
			if (beacon_ping > 0)
				beacon_ping_str = std::to_string(beacon_ping);

			if (beacon_status == "Hosting, Waiting" &&
				ImGui::Selectable(beacon_ping_str.c_str(), &is_selected, ImGuiSelectableFlags_SpanAllColumns))
			{
				dojo.PlayMatch = false;

				config::ActAsServer = false;
				config::DojoServerIP = beacon_ip;
				config::DojoServerPort = beacon_server_port;

				SaveSettings();

				gui_state = GuiState::Closed;
				gui_start_game(beacon_game_path);
			}

			std::string popup_name = "Options " + beacon_id;
			if (ImGui::BeginPopupContextItem(popup_name.c_str(), 1))
			{
				if (beacon_remaining_spectators == "0")
				{
					ImGui::MenuItem("Spectate", NULL, false, false);
				}
				else
				{
					if (ImGui::MenuItem("Spectate"))
					{
						dojo.PlayMatch = false;

						config::Receiving = true;
						dojo.receiving = true;

						config::ActAsServer = false;
						dojo.hosting = false;

						dojo.RequestSpectate(beacon_ip, beacon_server_port);

						gui_start_game(beacon_game_path);
					}
				}

				ImGui::EndPopup();
			}

			ImGui::NextColumn();

			ImGui::Text(beacon_player.c_str());  ImGui::NextColumn();
			ImGui::Text(beacon_status.c_str());  ImGui::NextColumn();
			ImGui::Text(beacon_game.c_str()); ImGui::NextColumn();
		}
	}

    ImGui::End();
    ImGui::PopStyleVar();
}

void DojoGui::show_playback_menu(float scaling, bool paused)
{
	if (!config::ShowPlaybackControls)
	{
		if (config::EnablePlayerNameOverlay)
			show_player_name_overlay(scaling, true);
		return;
	}

	unsigned int total = dojo.net_inputs[0].size();
	int position = dojo.FrameNumber.load();

	if (!paused)
	{
		ImGui_Impl_NewFrame();
		ImGui::NewFrame();
	}

	ImGui::SetNextWindowBgAlpha(0.6f);
	ImGui::SetNextWindowPos(ImVec2((screen_width / 2) - 220, screen_height - 45));
	ImGui::SetNextWindowSize(ImVec2(440, 40));

	ImGui::Begin("##fn", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDecoration );


	ImGui::SliderInt("", &position, 0, total);
	ImGui::SameLine();
	ImGui::Text("%u", total);

	ImGui::SameLine();

	if (!paused)
	{
		if (ImGui::Button("Pause"))
		{
			TermAudio();
			gui_state = GuiState::ReplayPause;
		}

		ImGui::SameLine();
		if (ImGui::Button("Hide"))
		{
			config::ShowPlaybackControls = false;
		}
	}
	else
	{
		if (ImGui::Button("Play"))
		{
			InitAudio();
			gui_state = GuiState::Closed;
		}
	}

	ImGui::End();

	if (!paused)
	{
		ImGui::Render();
		ImGui_impl_RenderDrawData(ImGui::GetDrawData());
	}
}

void DojoGui::show_player_name_overlay(float scaling, bool paused)
{
	std::string player_1;
	std::string player_2;

	if (dojo.hosting || dojo.PlayMatch)
	{
		player_1 = config::PlayerName;
		player_2 = config::OpponentName;
	}
	else
	{
		player_1 = config::OpponentName;
		player_2 = config::PlayerName;
	}

	float font_size_1 = ImGui::GetFontSize() * player_1.size() / 2;
	float font_size_2 = ImGui::GetFontSize() * player_2.size() / 2;

	//ImGui_Impl_NewFrame();
	ImGui::NewFrame();

	ImGui::SetNextWindowBgAlpha(0.5f);
	ImGui::SetNextWindowPos(ImVec2((screen_width / 4) - (font_size_1 / 2), 0));
	ImGui::SetNextWindowSize(ImVec2(font_size_1 + 10, 35));

	ImGui::Begin("##fn", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDecoration );

	ImGui::SameLine(
        ImGui::GetWindowSize().x / 2 -
        font_size_1 + (font_size_1 / 2) + 5
    );

    ImGui::Text(player_1.c_str());

	ImGui::End();
	ImGui::Render();
	ImGui_impl_RenderDrawData(ImGui::GetDrawData());


	//ImGui_Impl_NewFrame();
	ImGui::NewFrame();

	ImGui::SetNextWindowBgAlpha(0.5f);
	ImGui::SetNextWindowPos(ImVec2(((screen_width / 4) * 3) - (font_size_2 / 2), 0) );
	ImGui::SetNextWindowSize(ImVec2(font_size_2 + 10, 35));

	ImGui::Begin("##fn", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDecoration );

	ImGui::SameLine(
        ImGui::GetWindowSize().x / 2 -
        font_size_2 + (font_size_2 / 2) + 5
    );

    ImGui::Text(player_2.c_str());

	ImGui::End();
	ImGui::Render();
	ImGui_impl_RenderDrawData(ImGui::GetDrawData());
}

void DojoGui::gui_display_paused(float scaling)
{
	show_playback_menu(scaling, true);
}

void DojoGui::gui_display_replays(float scaling, std::vector<GameMedia> game_list)
{
	ImGui::SetNextWindowPos(ImVec2(0, 0));
	ImGui::SetNextWindowSize(ImVec2(screen_width, screen_height));
	ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0);

	ImGui::Begin("Replays", NULL, /*ImGuiWindowFlags_AlwaysAutoResize |*/ ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoCollapse);
	ImVec2 normal_padding = ImGui::GetStyle().FramePadding;

	if (ImGui::Button("Done", ImVec2(100 * scaling, 30 * scaling)))
	{
		cfgSaveBool("dojo", "RecordMatches", config::RecordMatches);
		if (game_started)
			gui_state = GuiState::Commands;
		else
			gui_state = GuiState::Main;
	}

	ImGui::SameLine(ImGui::GetContentRegionAvail().x - ImGui::CalcTextSize("Record All Sessions").x - ImGui::GetStyle().FramePadding.x * 4.0f - ImGui::GetStyle().ItemSpacing.x * 4);

	OptionCheckbox("Record All Sessions", config::RecordMatches);
	ImGui::SameLine();
	ShowHelpMarker("Record all netplay sessions to a local file");

	ImGui::Columns(3, "mycolumns"); // 4-ways, with border
	ImGui::Separator();
	ImGui::Text("Date"); ImGui::NextColumn();
	ImGui::Text("Players"); ImGui::NextColumn();
	ImGui::Text("Game"); ImGui::NextColumn();
	ImGui::Separator();

	fs::path path = fs::current_path() / "replays";
	std::map<std::string, std::string> replays;
	for (auto& p : fs::directory_iterator(path))
	{
		std::string replay_path = p.path().string();

		std::string s = replay_path;
		std::string delimiter = "__";

		std::vector<std::string> replay_entry;

		size_t pos = 0;
		std::string token;
		while ((pos = s.find(delimiter)) != std::string::npos) {
		    token = s.substr(0, pos);
		    //std::cout << token << std::endl;
			replay_entry.push_back(token);
		    s.erase(0, pos + delimiter.length());
		}

#ifdef _WIN32
		std::string game_name = replay_entry[0].substr(replay_entry[0].rfind("\\") + 1);
#else
		std::string game_name = replay_entry[0].substr(replay_entry[0].rfind("/") + 1);
#endif

		std::string date = replay_entry[1];
		std::string host_player = replay_entry[2];
		std::string guest_player = replay_entry[3];

		std::string game_path = "";

		std::vector<GameMedia> games = game_list;
		std::vector<GameMedia>::iterator it = std::find_if (games.begin(), games.end(),
			[&](GameMedia gm) { return ( gm.name.rfind(game_name, 0) == 0 ); });

		if (it != games.end())
		{
			game_path = it->path;
		}

		bool is_selected = false;
		if (ImGui::Selectable(date.c_str(), &is_selected, ImGuiSelectableFlags_SpanAllColumns))
		{
			dojo.ReplayFilename = replay_path;
			dojo.PlayMatch = true;

			gui_state = GuiState::Closed;
			//dojo.StartDojoSession();

			config::DojoEnable = true;
			gui_start_game(game_path);
		}
		ImGui::NextColumn();

		std::string players = host_player;
		if (!guest_player.empty())
			players += " vs " + guest_player;
		ImGui::Text(players.c_str());  ImGui::NextColumn();
		ImGui::Text(game_name.c_str());  ImGui::NextColumn();
	}

    ImGui::End();
    ImGui::PopStyleVar();
}

void DojoGui::insert_netplay_tab(ImVec2 normal_padding)
{
	if (ImGui::BeginTabItem("Dojo"))
	{
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, normal_padding);

		char PlayerName[256] = { 0 };
		strcpy(PlayerName, config::PlayerName.get().c_str());
		ImGui::InputText("Player Name", PlayerName, sizeof(PlayerName), ImGuiInputTextFlags_CharsNoBlank, nullptr, nullptr);
		ImGui::SameLine();
		ShowHelpMarker("Name visible to other players");
		config::PlayerName = std::string(PlayerName, strlen(PlayerName));

		OptionCheckbox("Enable Player Name Overlay", config::EnablePlayerNameOverlay);
		ImGui::SameLine();
		ShowHelpMarker("Enable overlay showing player names during netplay sessions & replays");

		if (ImGui::CollapsingHeader("Replays", ImGuiTreeNodeFlags_DefaultOpen))
		{
			OptionCheckbox("Show Playback Controls", config::ShowPlaybackControls);
			ImGui::SameLine();
			ShowHelpMarker("Shows current position and controls on playback. Hides player name overlay while on screen.");

			OptionCheckbox("Record All Sessions", config::RecordMatches);
			ImGui::SameLine();
			ShowHelpMarker("Record all gameplay sessions to a local file");
		}

		if (ImGui::CollapsingHeader("Netplay", ImGuiTreeNodeFlags_DefaultOpen))
		{
			std::string PortDescription = "The server port to listen on";

			char ServerPort[256];
			strcpy(ServerPort, config::DojoServerPort.get().c_str());
			ImGui::InputText("Server Port", ServerPort, sizeof(ServerPort), ImGuiInputTextFlags_CharsNoBlank, nullptr, nullptr);
			ImGui::SameLine();
			ShowHelpMarker(PortDescription.c_str());
			config::DojoServerPort = ServerPort;

			if (!config::EnableLobby)
			{
				OptionCheckbox("Enable Internet Matchmaking", config::EnableMatchCode);
				ImGui::SameLine();
				ShowHelpMarker("Enable Internet matchmaking. Establishes direct connection via public server relay.");

				if (config::EnableMatchCode)
				{
					if (ImGui::CollapsingHeader("Internet Matchmaking", ImGuiTreeNodeFlags_DefaultOpen))
					{
						char MatchmakingServerAddress[256];

						strcpy(MatchmakingServerAddress, config::MatchmakingServerAddress.get().c_str());
						ImGui::InputText("Matchmaking Service Address", MatchmakingServerAddress, sizeof(MatchmakingServerAddress), ImGuiInputTextFlags_CharsNoBlank, nullptr, nullptr);
						config::MatchmakingServerAddress = MatchmakingServerAddress;

						char MatchmakingServerPort[256];

						strcpy(MatchmakingServerPort, config::MatchmakingServerPort.get().c_str());
						ImGui::InputText("Matchmaking Service Port", MatchmakingServerPort, sizeof(MatchmakingServerPort), ImGuiInputTextFlags_CharsNoBlank, nullptr, nullptr);
						config::MatchmakingServerPort = MatchmakingServerPort;
					}
				}
			}

			if (!config::EnableMatchCode)
			{
				OptionCheckbox("Enable LAN Lobby", config::EnableLobby);
				ImGui::SameLine();
				ShowHelpMarker("Enable discovery and matchmaking over LAN");

				if (config::EnableLobby)
				{
					if (ImGui::CollapsingHeader("LAN Lobby", ImGuiTreeNodeFlags_DefaultOpen))
					{
						char LobbyMulticastAddress[256];

						strcpy(LobbyMulticastAddress, config::LobbyMulticastAddress.get().c_str());
						ImGui::InputText("Lobby Multicast Address", LobbyMulticastAddress, sizeof(LobbyMulticastAddress), ImGuiInputTextFlags_CharsNoBlank, nullptr, nullptr);
						ImGui::SameLine();
						ShowHelpMarker("Multicast IP Address for Lobby to Target");
						config::LobbyMulticastAddress = LobbyMulticastAddress;

						char LobbyMulticastPort[256];

						strcpy(LobbyMulticastPort, config::LobbyMulticastPort.get().c_str());
						ImGui::InputText("Lobby Multicast Port", LobbyMulticastPort, sizeof(LobbyMulticastPort), ImGuiInputTextFlags_CharsNoBlank, nullptr, nullptr);
						ImGui::SameLine();
						ShowHelpMarker("Multicast Port for Lobby to Target");
						config::LobbyMulticastPort = LobbyMulticastPort;
					}
				}
			}
		}

		if (ImGui::CollapsingHeader("Session Streaming", ImGuiTreeNodeFlags_DefaultOpen))
		{
			OptionCheckbox("Enable Session Transmission", config::Transmitting);
			ImGui::SameLine();
			ShowHelpMarker("Transmit netplay sessions as TCP stream to target spectator");

			if (config::Transmitting)
			{
				char SpectatorIP[256];

				strcpy(SpectatorIP, config::SpectatorIP.get().c_str());
				ImGui::InputText("Spectator IP Address", SpectatorIP, sizeof(SpectatorIP), ImGuiInputTextFlags_CharsNoBlank, nullptr, nullptr);
				ImGui::SameLine();
				ShowHelpMarker("Target Spectator IP Address");
				config::SpectatorIP = SpectatorIP;

				OptionCheckbox("Transmit Replays", config::TransmitReplays);
				ImGui::SameLine();
				ShowHelpMarker("Transmit replays to target spectator");
			}

			char SpectatorPort[256];

			strcpy(SpectatorPort, config::SpectatorPort.get().c_str());
			ImGui::InputText("Spectator Port", SpectatorPort, sizeof(SpectatorPort), ImGuiInputTextFlags_CharsNoBlank, nullptr, nullptr);
			ImGui::SameLine();
			ShowHelpMarker("Port to send or receive session streams");
			config::SpectatorPort = SpectatorPort;

			int one = 1;
			ImGui::InputScalar("Frame Buffer", ImGuiDataType_S32, &config::RxFrameBuffer.get(), &one, NULL, "%d");
			ImGui::SameLine();
			ShowHelpMarker("# of frames to cache before playing received match stream");
		}

		if (ImGui::CollapsingHeader("Memory Management", ImGuiTreeNodeFlags_None))
		{
			OptionCheckbox("Enable NVMEM/EEPROM Restoration", config::EnableMemRestore);
			ImGui::SameLine();
			ShowHelpMarker("Restores NVMEM & EEPROM files before netplay session to prevent desyncs. Disable if you wish to use modified files with your opponent. (i.e., palmods, custom dipswitches)");

			OptionCheckbox("Ignore Existing Netplay Savestates", config::IgnoreNetSave);
			ImGui::SameLine();
			ShowHelpMarker("Ignore previously generated or custom savestates ending in .net. Generates fallback savestate for every match.");

			OptionCheckbox("Allow Custom VMUs", config::NetCustomVmu);
			ImGui::SameLine();
			ShowHelpMarker("Allows custom VMUs for netplay ending in .bin.net. VMU must match opponent's. Deletes and regenerates blank Dreamcast VMUs for netplay when disabled.");
		}

		if (ImGui::CollapsingHeader("Advanced", ImGuiTreeNodeFlags_None))
		{
			ImGui::SliderInt("Packets Per Frame", (int*)&config::PacketsPerFrame.get(), 1, 10);
			ImGui::SameLine();
			ShowHelpMarker("Number of packets to send per input frame.");

			OptionCheckbox("Enable Backfill", config::EnableBackfill);
			ImGui::SameLine();
			ShowHelpMarker("Transmit past input frames along with current one in packet payload. Aids in unreliable connections.");

			if (config::EnableBackfill)
			{
				ImGui::SliderInt("Number of Past Input Frames", (int*)&config::NumBackFrames.get(), 1, 40);
				ImGui::SameLine();
				ShowHelpMarker("Number of past inputs to send per frame.");
			}
		}

		ImGui::PopStyleVar();
		ImGui::EndTabItem();
	}
}

void DojoGui::update_action()
{
	if (ImGui::BeginPopupModal("Update?", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiInputTextFlags_EnterReturnsTrue))
	{
		std::string tag_name;
		std::string download_url;

		std::tie(tag_name, download_url) = dojo_file.tag_download;

		if (strcmp(tag_name.data(), REICAST_VERSION) != 0)
		{
			ImGui::Text("There is a new version of Flycast Dojo available.\nWould you like to Update?");

			if (ImGui::BeginPopupModal("Update", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiInputTextFlags_EnterReturnsTrue))
			{
				ImGui::Text(dojo_file.status_text.data());
				if (strcmp(dojo_file.status_text.data(), "Update complete.\nPlease restart Flycast Dojo to use new version.") == 0)
				{
					if (ImGui::Button("Exit"))
					{
						exit(0);
					}
				}
				else
				{
					float progress 	= float(dojo_file.downloaded_size) / float(dojo_file.total_size);
					char buf[32];
					sprintf(buf, "%d/%d", (int)(progress * dojo_file.total_size), dojo_file.total_size);
					ImGui::ProgressBar(progress, ImVec2(0.f, 0.f), buf);
				}
				ImGui::EndPopup();
			}

			if (ImGui::Button("Update"))
			{
				ImGui::OpenPopup("Update");
				dojo_file.start_update = true;
			}
			ImGui::SameLine();
		}
		else
		{
			ImGui::Text("Flycast Dojo is already on the newest version.");
		}

		if (ImGui::Button("Close"))
		{
			ImGui::CloseCurrentPopup();
		}

		ImGui::EndPopup();
	}

	if (dojo_file.start_update && !dojo_file.update_started)
	{
		std::thread t([&]() {
			dojo_file.Update();
		});
		t.detach();
	}

}

DojoGui dojo_gui;

